
module sigma(x){
   Const const1;
   Const const2;
   Const const3;
#
   res = (x >>< const1) ^ (x >>< const2) ^ (x >> const3);
   res -> out;
}

module Sigma(x){
   Const const1;
   Const const2;
   Const const3;
#
   res = (x >>< const1) ^ (x >>< const2) ^ (x >>< const3);
   res -> out;
}

module CH(a,b,c){
#
   res = (a & b) ^ (~a & c);
   res -> out;
}

module CHImpl(){
   Const a;
   Const b;
   Const c;
   CH ch;
   Reg output;
#
   a -> ch:0;
   b -> ch:1;
   c -> ch:2;

   ch -> output;
}

module Maj(x,y,z){
#
   res = (x & y) ^ (x & z) ^ (y & z);
   res -> out;
}

module sigma_stage(x,y){
   sigma sigma0;
   sigma sigma1;
#
   x -> sigma0;
   y -> sigma1;

   sigma0 -> out:0;
   sigma1 -> out:1;
}

module Comb_M_Stage(w0,w14,w9,w1){
   static sigma_stage sigma;
#
   w1 -> sigma:0;
   w14 -> sigma:1;
  
   res = sigma:0 + w0 + sigma:1 + w9;
   res -> out;
}

module M_Stage(w0,w14,w9,w1){
   Comb_M_Stage comb;
   PipelineRegister r;
#
   w0 -> comb:0;
   w14 -> comb:1;
   w9 -> comb:2;
   w1 -> comb:3;

   comb -> r;

   r -> out;
}

module M(w){
   M_Stage m0;
   M_Stage m1;
   M_Stage m2;
   M_Stage m3;
   M_Stage m4;
   M_Stage m5;
   M_Stage m6;
   M_Stage m7;
   M_Stage m8;
   M_Stage m9;
   M_Stage ma;
   M_Stage mb;
   M_Stage mc;
   M_Stage md;
   M_Stage me;
   M_Stage mf;
   Merge merge;
#
   w[0] -> m0:0;
   w[14] -> m0:1;
   w[9] -> m0:2;
   w[1] -> m0:3;

   w[1] -> m1:0;
   w[15] -> m1:1;
   w[10] -> m1:2;
   w[2] -> m1:3;
   
   w[2] -> m2:0;
   m0 -> m2:1;
   w[11] -> m2:2;
   w[3] -> m2:3;
   
   w[3] -> m3:0;
   m1 -> m3:1;
   w[12] -> m3:2;
   w[4] -> m3:3;
   
   w[4] -> m4:0;
   m2 -> m4:1;
   w[13] -> m4:2;
   w[5] -> m4:3;
   
   w[5] -> m5:0;
   m3 -> m5:1;
   w[14] -> m5:2;
   w[6] -> m5:3;
   
   w[6] -> m6:0;
   m4 -> m6:1;
   w[15] -> m6:2;
   w[7] -> m6:3;
   
   w[7] -> m7:0;
   m5 -> m7:1;
   m0 -> m7:2;
   w[8] -> m7:3;
   
   w[8] -> m8:0;
   m6 -> m8:1;
   m1 -> m8:2;
   w[9] -> m8:3;
   
   w[9] -> m9:0;
   m7 -> m9:1;
   m2 -> m9:2;
   w[10] -> m9:3;
   
   w[10] -> ma:0;
   m8 -> ma:1;
   m3 -> ma:2;
   w[11] -> ma:3;
   
   w[11] -> mb:0;
   m9 -> mb:1;
   m4 -> mb:2;
   w[12] -> mb:3;
   
   w[12] -> mc:0;
   ma -> mc:1;
   m5 -> mc:2;
   w[13] -> mc:3;
   
   w[13] -> md:0;
   mb -> md:1;
   m6 -> md:2;
   w[14] -> md:3;
   
   w[14] -> me:0;
   mc -> me:1;
   m7 -> me:2;
   w[15] -> me:3;
   
   w[15] -> mf:0;
   md -> mf:1;
   m8 -> mf:2;
   m0 -> mf:3;

   m0 -> merge:0;
   m1 -> merge:1;
   m2 -> merge:2;
   m3 -> merge:3;
   m4 -> merge:4;
   m5 -> merge:5;
   m6 -> merge:6;
   m7 -> merge:7;
   m8 -> merge:8;
   m9 -> merge:9;
   ma -> merge:10;
   mb -> merge:11;
   mc -> merge:12;
   md -> merge:13;
   me -> merge:14;
   mf -> merge:15;

   merge -> out;
}

module T1(e,f,g,h,k,w){
   CH ch;
   Sigma s;
#   
   e -> s;

   e -> ch:0;
   f -> ch:1;
   g -> ch:2;

   a1 = h + s:0;
   a2 = ch + k;
   a3 = a1 + a2;
   
   b1 = a3 + w;

   b1 -> out;
}

module T2(a,b,c){
   Sigma s;
   Maj m;
#
   a -> s;

   a -> m:0;
   b -> m:1;
   c -> m:2;

   d = s + m;

   d -> out; 
}

module T_Stage(a,b,c,e,f,g,h,k,w){
   T1 t1;
   T2 t2;
#
   a -> t2:0;
   b -> t2:1;
   c -> t2:2;

   e -> t1:0;
   f -> t1:1;
   g -> t1:2;
   h -> t1:3;
   k -> t1:4;
   w -> t1:5;

   t1 -> out:0;
   t2 -> out:1;
}

module Comb_F_Stage(a,b,c,d,e,f,g,h,k,w){
   static T_Stage t;
#
   a -> t:0;
   b -> t:1;
   c -> t:2;

   e -> t:3;
   f -> t:4;
   g -> t:5;
   h -> t:6;
   k -> t:7;
   w -> t:8;

   a1 = t:0 + t:1;
   a2 = d + t:0;

   a1 -> out:0;
   a  -> out:1;
   b  -> out:2;
   c  -> out:3;
   a2 -> out:4;
   e  -> out:5;
   f  -> out:6;
   g  -> out:7;
}

module F_Stage(a,b,c,d,e,f,g,h,k,w){
   Comb_F_Stage f_stage;
   PipelineRegister d0;
   PipelineRegister d1;
   PipelineRegister d2;
   PipelineRegister d3;
   PipelineRegister d4;
   PipelineRegister d5;
   PipelineRegister d6;
   PipelineRegister d7;
#
   a -> f_stage:0;
   b -> f_stage:1;
   c -> f_stage:2;
   d -> f_stage:3;
   e -> f_stage:4;
   f -> f_stage:5;
   g -> f_stage:6;
   h -> f_stage:7;
   k -> f_stage:8;
   w -> f_stage:9;

   f_stage:0 -> d0; // a
   f_stage:1 -> d1; // b
   f_stage:2 -> d2; // c
   f_stage:3 -> d3; // d
   f_stage:4 -> d4; // e
   f_stage:5 -> d5; // f
   f_stage:6 -> d6; // g
   f_stage:7 -> d7; // h

   d0 -> out:0;
   d1 -> out:1;
   d2 -> out:2;
   d3 -> out:3;
   d4 -> out:4;
   d5 -> out:5;
   d6 -> out:6;
   d7 -> out:7;
}

module F(a,b,c,d,e,f,g,h,k,w){
   F_Stage f0;
   F_Stage f1;
   F_Stage f2;
   F_Stage f3;
   F_Stage f4;
   F_Stage f5;
   F_Stage f6;
   F_Stage f7;
   F_Stage f8;
   F_Stage f9;
   F_Stage fa;
   F_Stage fb;
   F_Stage fc;
   F_Stage fd;
   F_Stage fe;
   F_Stage ff;
#
   a ->  f0:0;
   b ->  f0:1;
   c ->  f0:2;
   d ->  f0:3;
   e ->  f0:4;
   f ->  f0:5;
   g ->  f0:6;
   h ->  f0:7;
   k[0] -> f0:8;
   w[0] -> f0:9;

   f0:0..7 -> f1:0..7;
   k[1] -> f1:8;
   w[1] -> f1:9;

   f1:0..7 -> f2:0..7;
   k[2] -> f2:8;
   w[2] -> f2:9;

   f2:0..7 -> f3:0..7;
   k[3] -> f3:8;
   w[3] -> f3:9;

   f3:0..7 -> f4:0..7;
   k[4] -> f4:8;
   w[4] -> f4:9;

   f4:0..7 -> f5:0..7;
   k[5] -> f5:8;
   w[5] -> f5:9;

   f5:0..7 -> f6:0..7;
   k[6] -> f6:8;
   w[6] -> f6:9;

   f6:0..7 -> f7:0..7;
   k[7] -> f7:8;
   w[7] -> f7:9;

   f7:0..7 -> f8:0..7;
   k[8] -> f8:8;
   w[8] -> f8:9;

   f8:0..7 -> f9:0..7;
   k[9] -> f9:8;
   w[9] -> f9:9;

   f9:0..7 -> fa:0..7;
   k[10] -> fa:8;
   w[10] -> fa:9;

   fa:0..7 -> fb:0..7;
   k[11] -> fb:8;
   w[11] -> fb:9;

   fb:0..7 -> fc:0..7;
   k[12] -> fc:8;
   w[12] -> fc:9;

   fc:0..7 -> fd:0..7;
   k[13] -> fd:8;
   w[13] -> fd:9;

   fd:0..7 -> fe:0..7;
   k[14] -> fe:8;
   w[14] -> fe:9;

   fe:0..7 -> ff:0..7;
   k[15] -> ff:8;
   w[15] -> ff:9;

   ff:0..7 -> out:0..7;
}

module ShaSingleState(in){
   Reg reg;
#
   a = reg + in;
   a -> reg;
   reg -> out;
}

// Simple grouping of state so it appears better on the graphs
module ShaState(x[8]){
   ShaSingleState s[8];
#
   x[0..7] -> s[0..7];
   s[0..7] -> out:0..7;
}

module Constants(){
   static OnlyOutputMem mem;
#
   mem -> out:0;
}

module SHA(){
   VRead MemRead;
   SwapEndian Swap;
   xunitF F0;
   xunitF F1;
   xunitF F2;
   xunitF F3;
   xunitM M0;
   xunitM M1;
   xunitM M2;
   Constants cMem0;
   Constants cMem1;
   Constants cMem2;
   Constants cMem3;
   ShaState State;
#
   MemRead -> Swap;
   
   {State:0..7,cMem0,Swap} -> F0:0..9;
   {F0:0..7   ,cMem1,M0} -> F1:0..9;
   {F1:0..7   ,cMem2,M1} -> F2:0..9;
   {F2:0..7   ,cMem3,M2} -> F3:0..9;

   Swap -> M0;
   M0 -> M1;
   M1 -> M2;
   
   F3:0..7 -> State:0..7;
}

module SBox(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,xa,xb,xc,xd,xe,xf){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) s0;
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) s1;
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) s2;
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) s3;
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) s4;
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) s5;
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) s6;
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) s7;
#
   x0 -> s0:0;
   x1 -> s0:1;

   x2 -> s1:0;
   x3 -> s1:1;

   x4 -> s2:0;
   x5 -> s2:1;

   x6 -> s3:0;
   x7 -> s3:1;

   x8 -> s4:0;
   x9 -> s4:1;

   xa -> s5:0;
   xb -> s5:1;

   xc -> s6:0;
   xd -> s6:1;

   xe -> s7:0;
   xf -> s7:1;

   s0:0 -> out:0;
   s0:1 -> out:1;
   s1:0 -> out:2;
   s1:1 -> out:3;
   s2:0 -> out:4;
   s2:1 -> out:5;
   s3:0 -> out:6;
   s3:1 -> out:7;
   s4:0 -> out:8;
   s4:1 -> out:9;
   s5:0 -> out:10;
   s5:1 -> out:11;
   s6:0 -> out:12;
   s6:1 -> out:13;
   s7:0 -> out:14;
   s7:1 -> out:15;
}

module ShiftRows(x[16]){
#
   // First row
   {x[0],x[4],x[8],x[12]} -> {out:0,out:4,out:8,out:12};

   // Second row
   {x[1],x[5],x[9],x[13]} -> {out:13,out:1,out:5,out:9};

   // Third row
   {x[2],x[6],x[10],x[14]} -> {out:10,out:14,out:2,out:6};

   // Fourth row
   {x[3],x[7],x[11],x[15]} -> {out:7,out:11,out:15,out:3};
}

module InvShiftRows(x[16]){
#
   // First row
   {x[0],x[4],x[8],x[12]} -> {out:0,out:4,out:8,out:12};

   // Second row
   {x[1],x[5],x[9],x[13]} -> {out:5,out:9,out:13,out:1};

   // Third row
   {x[2],x[6],x[10],x[14]} -> {out:10,out:14,out:2,out:6};

   // Fourth row
   {x[3],x[7],x[11],x[15]} -> {out:15,out:3,out:7,out:11};
}

module InvDoRow(x[4]){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul9[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul11[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul13[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul14[2];
#
   // "Multiple" (lookup) each by 9,11,13,14
   x[0..3] -> { mul9[0]:0..1, mul9[1]:0..1};
   x[0..3] -> {mul11[0]:0..1,mul11[1]:0..1};
   x[0..3] -> {mul13[0]:0..1,mul13[1]:0..1};
   x[0..3] -> {mul14[0]:0..1,mul14[1]:0..1};

   r0 = mul14[0] ^ mul11[0]:1 ^ mul13[1] ^  mul9[1]:1;
   r1 =  mul9[0] ^ mul14[0]:1 ^ mul11[1] ^ mul13[1]:1;
   r2 = mul13[0] ^  mul9[0]:1 ^ mul14[1] ^ mul11[1]:1;
   r3 = mul11[0] ^ mul13[0]:1 ^  mul9[1] ^ mul14[1]:1;

   {r0,r1,r2,r3} -> out:0..3;
}

module DoRow(x[4]){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul2[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul3[2];
#
   // "Multiple" (lookup) each by 2 and by 3
   x[0..3] -> {mul2[0]:0..1,mul2[1]:0..1};
   x[0..3] -> {mul3[0]:0..1,mul3[1]:0..1};

   r0 = x[2] ^ x[3] ^ mul2[0]   ^ mul3[0]:1;
   r1 = x[0] ^ x[3] ^ mul2[0]:1 ^ mul3[1] ;
   r2 = x[0] ^ x[1] ^ mul2[1]   ^ mul3[1]:1;
   r3 = x[1] ^ x[2] ^ mul2[1]:1 ^ mul3[0];

   {r0,r1,r2,r3} -> out:0..3;
}

module MixColumns(x[16]){
   DoRow d[4];
#
   {x[0],x[1],x[2],x[3]}  -> d[0]:0..3;
   {x[4],x[5],x[6],x[7]}  -> d[1]:0..3;
   {x[8],x[9],x[10],x[11]} -> d[2]:0..3;
   {x[12],x[13],x[14],x[15]} -> d[3]:0..3;

   d[0]:0..3 -> {out:0,out:1,out:2,out:3};
   d[1]:0..3 -> {out:4,out:5,out:6,out:7};
   d[2]:0..3 -> {out:8,out:9,out:10,out:11};
   d[3]:0..3 -> {out:12,out:13,out:14,out:15};
}

module InvMixColumns(x[16]){
   InvDoRow d[4];
#
   {x[0],x[1],x[2],x[3]}  -> d[0]:0..3;
   {x[4],x[5],x[6],x[7]}  -> d[1]:0..3;
   {x[8],x[9],x[10],x[11]} -> d[2]:0..3;
   {x[12],x[13],x[14],x[15]} -> d[3]:0..3;

   d[0]:0..3 -> {out:0,out:1,out:2,out:3};
   d[1]:0..3 -> {out:4,out:5,out:6,out:7};
   d[2]:0..3 -> {out:8,out:9,out:10,out:11};
   d[3]:0..3 -> {out:12,out:13,out:14,out:15};
}

module AddRoundKey(x[16],y[16]){
#
   a[0] = x[0] ^ y[0];
   a[1] = x[1] ^ y[1];
   a[2] = x[2] ^ y[2];
   a[3] = x[3] ^ y[3];
   a[4] = x[4] ^ y[4];
   a[5] = x[5] ^ y[5];
   a[6] = x[6] ^ y[6];
   a[7] = x[7] ^ y[7];
   a[8] = x[8] ^ y[8];
   a[9] = x[9] ^ y[9];
   a[10] = x[10] ^ y[10];
   a[11] = x[11] ^ y[11];
   a[12] = x[12] ^ y[12];
   a[13] = x[13] ^ y[13];
   a[14] = x[14] ^ y[14];
   a[15] = x[15] ^ y[15];

   a[0..15] -> out:0..15;
}

module MainRound(x[16],k[16]){
   SBox subBytes;
   ShiftRows shiftRows;
   MixColumns mixColumns;
   AddRoundKey addRoundKey;
#
   x[0..15] -> subBytes:0..15;
   
   subBytes:0..15 -> shiftRows:0..15;
   shiftRows:0..15 -> mixColumns:0..15;

   mixColumns:0..15 -> addRoundKey:0..15;
   k[0..15]         -> addRoundKey:16..31;

   addRoundKey:0..15 -> out:0..15;
}

module InvMainRound(x[16],k[16]){
   InvShiftRows invShiftRows;
   SBox invSubBytes;
   AddRoundKey invAddRoundKey;
   InvMixColumns invMixColumns;
#
   x[0..15] -> invShiftRows:0..15;
   invShiftRows:0..15 -> invSubBytes:0..15;

   invSubBytes:0..15 -> invAddRoundKey:0..15;
   k[0..15]          -> invAddRoundKey:16..31;

   invAddRoundKey:0..15 -> invMixColumns:0..15;
}

module FirstLineKey(x[4],w[4],rcon){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) b[2];
#
   {x[1],x[2],x[3],x[0]} -> {b[0]:0..1,b[1]:0..1};

   d[0] = b[0]:0 ^ w[0] ^ rcon;
   d[1] = b[0]:1 ^ w[1];
   d[2] = b[1]:0 ^ w[2];
   d[3] = b[1]:1 ^ w[3];

   d[0..3] -> out:0..3;
}

module FourthLineKey(x[4],w[4]){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) b[2];
#
   {x[0..1],x[2..3]} -> {b[0]:0..1,b[1]:0..1};

   d[0] = b[0]:0 ^ w[0];
   d[1] = b[0]:1 ^ w[1];
   d[2] = b[1]:0 ^ w[2];
   d[3] = b[1]:1 ^ w[3];

   d[0..3] -> out:0..3; 
}

module GenericLineKey(x[4],w[4],rcon){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) b[2];
   Mux2 mux[4];
#
   {x[0],x[1],x[2],x[3]} -> mux[0..3]:0; // Fourth line 
   {x[1],x[2],x[3],x[0]} -> mux[0..3]:1; // First line

   mux[0..3] -> {b[0]:0..1,b[1]:0..1};

   d[0] = b[0]:0 ^ w[0] ^ rcon;
   d[1] = b[0]:1 ^ w[1];
   d[2] = b[1]:0 ^ w[2];
   d[3] = b[1]:1 ^ w[3];

   d[0..3] -> out:0..3;
}

module GenericKeySchedule256(x[16],w[16],rcon){
   GenericLineKey s;
#
   {x[12],x[13],x[14],x[15]} -> s:0..3;
   {w[0],w[1],w[2],w[3]}     -> s:4..7;
   rcon -> s:8;

   a[0] = s:0 ^ w[4];
   a[1] = s:1 ^ w[5];
   a[2] = s:2 ^ w[6];
   a[3] = s:3 ^ w[7];

   b[0] = a[0] ^ w[8];
   b[1] = a[1] ^ w[9];
   b[2] = a[2] ^ w[10];
   b[3] = a[3] ^ w[11];

   c[0] = b[0] ^ w[12];
   c[1] = b[1] ^ w[13];
   c[2] = b[2] ^ w[14];
   c[3] = b[3] ^ w[15];

   s:0..3  -> out:0..3;
   a[0..3] -> out:4..7;
   b[0..3] -> out:8..11;
   c[0..3] -> out:12..15;
}

module AESFirstAdd(x[16],k[16],iv[16]){
   AddRoundKey addKey;
   AddRoundKey addKey2;
#
   x[0..15] -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> addKey2:0..15;
   iv[0..15]    -> addKey2:16..31;

   addKey2:0..15 -> out:0..15;
}

module AESInvFirstAdd(x[16],k[16],iv[16]){
   AddRoundKey addKey;
#
   x[0..15] -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> out:0..15;
}

module AESRound(x[16],k[16],iv[16]){
   SBox subBytes;
   ShiftRows shiftRows;
   MixColumns mixColumns;
   AddRoundKey addKey;
#   
   x[0..15] -> subBytes:0..15;
   subBytes:0..15 -> shiftRows:0..15;
   shiftRows:0..15 -> mixColumns:0..15;
   mixColumns:0..15 -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> out:0..15;
}

module AESInvRound(x[16],k[16],iv[16]){
   InvShiftRows invShiftRows;
   SBox subBytes;
   AddRoundKey addKey;
   InvMixColumns invMixColumns;
#
   x[0..15] -> invShiftRows:0..15;
   invShiftRows:0..15 -> subBytes:0..15;
   subBytes:0..15 -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> invMixColumns:0..15;

   invMixColumns:0..15 -> out:0..15;
}

module AESLastRound(x[16],key[16],iv[16]){
   SBox subBytes;
   ShiftRows shiftRows;
   AddRoundKey addKey;
#
   x[0..15] -> subBytes:0..15;
   subBytes:0..15 -> shiftRows:0..15;

   shiftRows:0..15 -> addKey:0..15;
   key[0..15]      -> addKey:16..31; 

   addKey:0..15 -> out:0..15;
}

module AESInvLastRound(x[16],key[16],iv[16]){
   InvShiftRows invShiftRows;
   SBox subBytes;
   AddRoundKey addKey;
   AddRoundKey removeIv;
#
   x[0..15] -> invShiftRows:0..15;
   invShiftRows:0..15 -> subBytes:0..15;

   subBytes:0..15 -> addKey:0..15;
   key[0..15]     -> addKey:16..31; 

   addKey:0..15 -> removeIv:0..15;
   iv[0..15]    -> removeIv:16..31;

   removeIv:0..15 -> out:0..15;
}

merge FullAESRounds = AESFirstAdd | AESRound | AESLastRound | AESInvFirstAdd | AESInvRound | AESInvLastRound;

module McEliece(){
   ReadWriteMem mat;
   VRead row;
   VWrite writer;
   Const mask;
#
   a = row & mask;
   b = mat ^ a;

   c = mat & mask;
   d = row ^ c;

   b -> mat;
   d -> writer;
}

module FullAES(){
   share config RegFile{
      key[16];
   }
   share config Reg{
      state[16];
   }
   share config Reg{
      lastResult[16];
   }
   share config Reg{
      lastValToAdd[16];
   }

   GenericKeySchedule256 schedule;
   Const rcon;
   FullAESRounds round;
   AddRoundKey lastAdd;
#
   key[0..15]:1 -> schedule:0..15;
   key[0..15]:0 -> schedule:16..31;
   rcon         -> schedule:32;

   schedule:0..15   -> key[0..15];

   state[0..15] -> round:0..15;
   key[0..15]   -> round:16..31;
   lastResult[0..15] -> round:32..47;

   round:0..15 -> lastAdd:0..15;
   lastValToAdd[0..15] -> lastAdd:16..31;

   lastAdd:0..15 -> state[0..15];
   lastAdd:0..15 -> lastResult[0..15];
}

module CryptoAlgos(){
   FullAES aes;
   SHA sha;
   McEliece eliece;
#
}
